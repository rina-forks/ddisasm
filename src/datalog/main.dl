//===- main.dl ----------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This is the main module of the datalog disassembler.
The disassembly has 3 main components:
 1- code_inference.dl
    -code_inference_postprocess.dl
    -cfg.dl
 2- symbolization.pl
    - use_def_analysis.dl
    - value_analysis.dl
    - data_access_analysis.dl
    - pointer_reattribution.dl

In addition there are several modules that consider special cases,
generic components and tables.

Special cases:
    -relative_jump_tables.dl

Generic components:
    -ordered_set.dl
    -empty_range.dl

Tables:
    -float_operations.dl
    -jump_operations.dl

This module:
- defines the input generated by the decoder
- defines a series of auxiliary predicates and basic facts that are used everywhere.
- defines some hard-code parameters of the analysis, such as the code and data sections
  explored.
*/

#define UNUSED(Var) Var = Var
#define SIMPLE_WEIGHT "simple"
#define PROPORTIONAL_WEIGHT "proportional"

/**
Register name as generated by capstone. May be "NONE" in some contexts.
*/
.type input_reg <: symbol

/**
Same as the "register" type, but may be "NONE".

Convert between input_reg and reg_nullable with arch.reg_map_nullable
*/
.type reg_nullable <: symbol

/*
A register represents all registers that share the same storage. For
example, the input_reg "AX" and "EAX" belong to the register "EAX" on x86.

Convert between input_reg and register with arch.reg_map
*/
.type register <: reg_nullable

.type address <: unsigned
.type operand_code <: unsigned
.type operand_index <: unsigned

.functor functor_aligned(EA:address,Size:unsigned):address

// Binary format specific predicates.
#include "binary/elf/elf_binaries.dl"
#include "binary/elf/symbolization.dl"
#include "binary/pe/pe_binaries.dl"
#include "binary/pe/jump_tables.dl"
#include "binary/pe/symbolization.dl"

// Architecture specific predicates.
#include "arch/arch.dl"

#ifdef ARCH_ARM64
    #include "arch/arm_binaries.dl"
    #include "arch/arm64_symbolization.dl"
#elif defined(ARCH_ARM32)
    #include "arch/arm_binaries.dl"
    #include "arch/arm32_binaries.dl"
    #include "arch/arm32_code_inference.dl"
    #include "arch/arm32_code_inference_weights.dl"
    #include "arch/arm32_jump_tables.dl"
    #include "arch/arm32_symbolization.dl"
#elif defined(ARCH_IA32)
    #include "arch/x86_32_symbolization.dl"
#elif defined(ARCH_AMD64)
    #include "arch/x86_64_symbolization.dl"
#elif defined(ARCH_MIPS32)
    #include "arch/mips_symbolization.dl"
#else
    #error "Undefined architecture"
#endif

// Binary data
#include "data.dl"

// Detection of jump tables.
#include "jump_tables.dl"
#include "relative_jump_tables.dl"

// def-used
#include "bitmasks.dl"
#include "basic_def_used.dl"
#include "straight_line_def_used.dl"

// Inference of instruction boundaries.
#include "code_inference.dl"
#include "code_inference_weights.dl"

// Infer special symbols and select symbols for symbolic expressions.
#include "symbols.dl"
// Performs literal-reference disambiguation and string inference.
#include "symbolization.dl"

// Inference of function boundaries.
#include "basic_function_inference.dl"

// Predicates for debugging and statistics.
#include "debug_stats.dl"
#include "self_diagnose.dl"
/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////

// metadata
.decl entry_point(ea:address)
.input entry_point
.output entry_point

.decl endianness(End:symbol) // Either LE or BE
.input endianness

.decl base_address(ea:address)
.input base_address

.decl symbol(ea:address,size:unsigned,type:symbol,scope:symbol,visibility:symbol,sectionIndex:unsigned,originTable:symbol,tableIndex:unsigned,name:symbol)
.input symbol

.decl section(Name:symbol,Size:unsigned,EA:address,Align:unsigned,Index:unsigned)
.input section

.decl section_property(Name:symbol,Property:symbol)
.input section_property

.decl section_type(Name:symbol,Type:unsigned)
.input section_type

.decl byte_interval(BegAddr:address,EndAddr:address)
.input byte_interval

.decl relocation(EA:address,Type:symbol,Name:symbol,Addend:number,SymbolIndex:unsigned,Section:symbol,RelType:symbol)
.input relocation

.decl relocation_size(Type:symbol,Size:unsigned)

/**
Defines adjustments to relocation values.
*/
.decl relocation_adjustment(EA:address,Adjustment:number,Reason:symbol)
/**
The total relocation adjustment for a location
*/
.decl relocation_adjustment_total(EA:address,Adjustment:number)

relocation_adjustment_total(EA,0):-
    relocation(EA,_,_,_,_,_,_),
    !relocation_adjustment(EA,_,_).

relocation_adjustment_total(EA,Adjustment):-
    relocation(EA,_,_,_,_,_,_),
    Adjustment = sum N:{relocation_adjustment(EA,N,_)}.

.decl binary_type(Type:symbol)
.input binary_type

.decl binary_format(Format:symbol)
.input binary_format

/**
ArchInfo auxdata derived ELF metadata
*/
.decl arch_info(Key:symbol,Value:symbol)
.input arch_info

.decl binary_isa(ArchName:symbol) inline

binary_isa(ArchName):-
    arch.arch(ArchName).

.decl option(Option:symbol)
.input option

.decl dynamic_entry(tag:symbol, value:unsigned)
.input dynamic_entry

// instructions

.decl instruction(ea:address,size:unsigned,prefix:symbol,opcode:symbol,
          op1:operand_code,op2:operand_code,op3:operand_code,op4:operand_code,
          immOffset:unsigned,displacementOffset:unsigned)
.input instruction
.output instruction

/**
 The instruction at EA has capstone's cs_arm.writeback set.
*/
.decl instruction_writeback(EA:address)
.input instruction_writeback

/**
 The instruction at EA has capstone's cs_arm.cc set.
*/
.decl instruction_cond_code(EA:address,CondCode:symbol)
.input instruction_cond_code

.type access_mode <: symbol

/**
The register Register is accessed at EA with AccessMode.

AccessMode may be "R" or "W"
*/
.decl register_access(EA:address,Register:input_reg,AccessMode:access_mode)
.input register_access

/**
The operand at index Index is accessed at EA with AccessMode
*/
.decl instruction_op_access(EA:address,Index:operand_index,AccessMode:access_mode)
.input instruction_op_access

/**
Index: The index of the register in bitfield (starts with 0)
*/
.decl op_register_bitfield(Code:operand_code,Index:unsigned,RegisterName:input_reg)
.input op_register_bitfield

.decl invalid_op_code(EA:address)
.input invalid_op_code

.decl op_regdirect(Code:operand_code,RegisterName:input_reg)
.input op_regdirect

.decl op_fp_immediate(Code:operand_code,Imm:float)
.input op_fp_immediate

.decl op_immediate(Code:operand_code,Offset:number,SizeBytes:unsigned)
.input op_immediate
.output op_immediate

.decl op_special(Code:operand_code,Type:symbol,Value:symbol)
.input op_special

.decl op_indirect(Code:operand_code,Reg1:input_reg,Reg2:input_reg,Reg3:input_reg,
        Multiplier:number,Offset:number,SizeBytes:unsigned)
.input op_indirect
.output op_indirect

/**
The operand identified by Index should be shifted with an immediate.

Used on ARM/ARM64, but not x86 or MIPS. Type is architecure-dependent.
*/
.decl op_shifted(EA:address,Index:operand_index,Shift:unsigned,Type:symbol)
.input op_shifted

/**
The operand identified by Index should be shifted with a register.

Used on ARM/ARM64, but not x86 or MIPS. Type is architecure-dependent.
*/
.decl op_shifted_w_reg(EA:address,Index:operand_index,Reg:input_reg,Type:symbol)
.input op_shifted_w_reg

/**
There is a potential address at 'EA' pointing to 'Value'.
*/
.decl address_in_data(EA:address,Value:address)
.input address_in_data

// known data regions
.decl data_region(Begin:address,Size:unsigned)
.input data_region

/**
Possible null-terminated ASCII string of 'Size' bytes begins at address 'EA'.
*/
.decl ascii_string(EA:address,End:address)
.input ascii_string

///////////////////////////////////////////////////////////////
// Initialize components

.init function_inference = basic_function_inference

/////////////////////////////////////////////////////////////
// register type conversions
/////////////////////////////////////////////////////////////

/**
Maps input_reg to registers referred to by a single name. This is used to allow
different register names that refer to the same storage to be tracked together,
e.g., on x86, both AX and EAX are members of the EAX register.
*/
.decl reg_map_nullable(RegIn:input_reg,Reg:reg_nullable)

reg_map_nullable(RegIn,Reg):-
    arch.reg_map_rule(RegIn,Reg).

// Any register not mapped by a rule is assumed to map to itself.
reg_map_nullable(Reg,as(Reg,reg_nullable)):-
    (
        op_regdirect(_,Reg);
        op_register_bitfield(_,_,Reg);
        op_indirect(_,_,Reg,_,_,_,_);
        op_indirect(_,_,_,Reg,_,_,_);
        register_access(_,Reg,_);
        op_shifted_w_reg(_,_,Reg,_)
    ),
    !arch.reg_map_rule(Reg,_).

.decl reg_nonnull(RegNullable:reg_nullable,Reg:register) inline

reg_nonnull(RegNullable,Reg):-
    RegNullable != "NONE",
    Reg = as(RegNullable,register).

.decl reg_map(RegIn:input_reg,Reg:register)

reg_map(RegIn,Reg):-
    reg_map_nullable(RegIn,RegNullable),
    reg_nonnull(RegNullable,Reg).

/////////////////////////////////////////////////////////////
// auxiliary definitions
/////////////////////////////////////////////////////////////

/**
This predicate determines the `Offset` and `Size` of an immediate operand of index `Index`.
This is used to place symbolic expressions at the right address.
The `Offset` is non-zero only for the x86 ISA, for other ISAs the symbolic
expressions point to the beginning of the instruction.
*/
.decl instruction_immediate_offset(EA:address,Index:operand_index,Offset:unsigned,Size:unsigned)

instruction_immediate_offset(EA,Index,ImmediateOffset,Size-ImmediateOffset):-
    instruction(EA,Size,_,_,_,_,_,_,ImmediateOffset,_),
    instruction_get_op(EA,Index,Op),
    op_immediate(Op,_,_).

/**
This predicate determines the `Offset` and `Size` of a displacement
in an indirect operand of index `Index`.
This is used to place symbolic expressions at the right address.
The `Offset` is non-zero only for the x86 ISA, for other ISAs the symbolic
expressions point to the beginning of the instruction.
*/
.decl instruction_displacement_offset(EA:address,Index:operand_index,Offset:unsigned,Size:unsigned)

instruction_displacement_offset(EA,Index,DisplacementOffset,DispSize):-
    instruction(EA,Size,_,_,_,_,_,_,ImmediateOffset,DisplacementOffset),
    instruction_get_op(EA,Index,Op),
    op_indirect(Op,_,_,_,_,_,_),
    (
        // x86 can have 'mov [Disp], Imm' (move immediate value to memory)
        // x86 encoding puts the immediate after the displacement so we need to
        // check the immediate offset to compute the size of the displacement
        ImmediateOffset > DisplacementOffset,
        DispSize = ImmediateOffset - DisplacementOffset,
        // avoid warning
        Size = Size
        ;
        ImmediateOffset <= DisplacementOffset,
        DispSize = Size - DisplacementOffset
    ).

.decl instruction_get_operation(ea:address,operation:symbol) inline

instruction_get_operation(EA,Operation):-
    instruction(EA,_,_,Operation,_,_,_,_,_,_).

.decl instruction_get_op(ea:address, index:operand_index, operator:operand_code)

instruction_get_op(EA,Index,Op):-
    instruction(EA,_,_,_,Op1,Op2,Op3,Op4,_,_),
    (
        Op1 != 0,
        Op = Op1, Index = 1,
        Op2 = Op2, Op3 = Op3, Op4 = Op4 // avoid warning
        ;
        Op2 != 0,
        Op = Op2, Index = 2,
        Op1 = Op1, Op3 = Op3, Op4 = Op4 // avoid warning
        ;
        Op3 != 0,
        Op = Op3, Index = 3,
        Op1 = Op1, Op2 = Op2, Op4 = Op4 // avoid warning
        ;
        Op4 != 0,
        Op = Op4, Index = 4,
        Op1 = Op1, Op2 = Op2, Op3 = Op3 // avoid warning
    ).

/**
Source operands
*/
.decl instruction_get_src_op(EA:address,Index:operand_index,Op:operand_code)

instruction_get_src_op(EA,Index,Op):-
    instruction_op_access(EA,Index,"R"),
    !arch.op_access_override(EA,Index,"R",0),
    instruction_get_op(EA,Index,Op).

instruction_get_src_op(EA,Index,Op):-
    arch.op_access_override(EA,Index,"R",1),
    instruction_get_op(EA,Index,Op).

/**
Destination operands
*/
.decl instruction_get_dest_op(EA:address,Index:operand_index,Op:operand_code)

instruction_get_dest_op(EA,Index,Op):-
    instruction_op_access(EA,Index,"W"),
    !arch.op_access_override(EA,Index,"W",0),
    instruction_get_op(EA,Index,Op).

instruction_get_dest_op(EA,Index,Op):-
    arch.op_access_override(EA,Index,"W",1),
    instruction_get_op(EA,Index,Op).

/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////

.decl next(n:address,m:address)

next(EA,EA+Size):-
    instruction(EA,Size,_,_,_,_,_,_,_,_).

.decl pc_relative_operand(src:address,index:operand_index, dest:address)

pc_relative_operand(EA,Index,Dest):-
    binary_isa("X64"),
    instruction_get_op(EA,Index,Op),
    op_indirect_mapped(Op,"NONE",Reg,"NONE",1,Offset,_),
    arch.pc_reg(Reg),
    next(EA,EANext),
    Dest = as(as(EANext,number)+Offset,address),
    !instruction_has_relocation(EA,_).

pc_relative_operand(EA,Index,Dest):-
    binary_isa("X64"),
    instruction_displacement_offset(EA,Index,Offset,_),
    relocation(EA+Offset,"PC32",_,Addend,SymbolIndex,_,_),
    symbol(Base,_,"SECTION",_,_,_,_,SymbolIndex,_),
    instruction(EA,Size,_,_,_,_,_,_,_,_),
    Dest = Base + as(as(Size-Offset,number)+Addend,unsigned).

.decl split_load_operand(src:address,index:operand_index, dest:address)

split_load_operand(0,0,0):- false.

.decl instruction_has_loop_prefix(EA:address)

instruction_has_loop_prefix(EA):-
    instruction(EA,_,Prefix,_,_,_,_,_,_,_),
    arch.loop_prefix(Prefix).

/**
Instruction at address "EA" has a relocation for address "Relocation".
*/
.decl instruction_has_relocation(EA:address,Rel:address)

instruction_has_relocation(EA,EA+Offset):-
    (
        binary_isa("X86");
        binary_isa("X64")
    ),
    (
        instruction_immediate_offset(EA,_,Offset,_);
        instruction_displacement_offset(EA,_,Offset,_)
    ),
    relocation(EA+Offset,_,_,_,_,_,_).

// JUMPS
.decl unconditional_jump(n:address)

unconditional_jump(EA):-
    arch.jump(EA),
    !arch.conditional(EA,_).

.decl conditional_jump(src:address)

conditional_jump(EA):-
    arch.jump(EA),
    arch.conditional(EA,_).

/**
This predicate represents a direct jump from address
`src` to destination `dest`. It captures only
direct jump whose destination is known.
E.g. a direct jump that depends on a relocation will
not produce a direct_jump term.
*/
.decl direct_jump(src:address, dest:address)

direct_jump(EA,as(Dest,address)):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.jump_operation_op_index(Operation,Index),
    instruction_get_op(EA,Index,Op),
    op_immediate(Op,Dest,_),
    (
        !instruction_has_relocation(EA,_)
    ;
        // Relocations in PEs don't override the destination by default,
        // only if base_image is changed.
        binary_format("PE")
    ).

direct_jump(EA,as(Dest,address)):-
    arch.jump(EA),
    instruction_immediate_offset(EA,_,_,_),
    instruction_has_relocation(EA,Rel),
    relocation(Rel,_,_,_,SymbolIndex,_,_),
    relocation_active_symbol_table(SymbolTable),
    defined_symbol(Dest,_,_,_,_,_,SymbolTable,SymbolIndex,_).

direct_jump(EA,EA):-
    instruction_has_loop_prefix(EA).

.decl impossible_jump_target(EA:address)

impossible_jump_target(0):-
    false.

/** This predicate represents a indirect jump
from address 'Src' to a destination contained in
the data pointer located at address 'DataPointer'.
The location of the pointer can be easily inferred because
it only depends on the program counter.
*/
.decl pc_relative_jump(Src:address, DataPointer:address)

pc_relative_jump(EA,DataPointer):-
    arch.jump(EA),
    pc_relative_operand(EA,1,DataPointer).

/**
The instruction at address 'Src' has a jump using
register 'Reg'. The destination of the jump will
be the value of the register.
*/
.decl reg_jump(Src:address,Reg:register)

reg_jump(EA,Reg):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_regdirect_contains_reg(TargetOp,Reg),
    !arch.pc_reg(Reg).

/**
The instruction at address 'Src' has an indirect jump.
I.e. a jump that reads its destination from memory.
*/
.decl indirect_jump(Src:address)

indirect_jump(EA):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_indirect(TargetOp,_,_,_, _,_,_).

/**
This predicate represents a direct call from address
'EA' to destination `Dest`. It captures only
direct calls whose destination is known.
E.g. a direct call that depends on a relocation will
not produce a direct_call term.
*/
.decl direct_call(EA:address,Dest:address)

direct_call(EA,as(Dest,address)):-
    !binary_isa("ARM"),
    arch.call(EA,Index),
    instruction_get_op(EA,Index,Op),
    op_immediate(Op,Dest,_),
    (
        !instruction_has_relocation(EA,_)
    ;
        // Relocations in PEs don't override the destination by default,
        // only if base_image is changed.
        binary_format("PE")
    ).

direct_call(EA,Dest):-
    !binary_isa("ARM"),
    arch.call(EA,_),
    instruction_immediate_offset(EA,_,_,_),
    instruction_has_relocation(EA,Rel),
    relocation(Rel,_,_,_,SymbolIndex,_,_),
    relocation_active_symbol_table(SymbolTable),
    defined_symbol(Dest,_,_,_,_,_,SymbolTable,SymbolIndex,_).

/** This predicate represents a indirect call
from address 'Src' to a destination contained in
the data pointer located at address 'DataPointer'.
The location of the pointer can be easily inferred because
it only depends on the program counter.
*/
.decl pc_relative_call(Src:address,DataPointer:address)

pc_relative_call(Src,DataPointer):-
    arch.call(Src,_),
    pc_relative_operand(Src,1,DataPointer).

/**
 The instruction at address 'Src' has a call using
 register 'Reg'. The destination of the call will
 be the value of the register.
*/
.decl reg_call(Src:address,Reg:register)

reg_call(EA,Reg):-
    arch.call(EA,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_regdirect_contains_reg(TargetOp,Reg).

/**
The instruction at address 'Src' has an indirect call.
I.e. a call that reads its destination from memory.
*/
.decl indirect_call(Src:address)

indirect_call(EA):-
    arch.call(EA,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_indirect(TargetOp,_,_,_,_,_,_),
    !arch.return(EA).

/**
Identify edge case direct calls that are used to load the program counter and
not as control-flow (e.g. call-to-pop sequences).
*/
.decl pc_load_call(Src:address,Dest:address)

// TODO: Replace with platform-specific definition of direct_call.
pc_load_call(Src,Dest):-
    (
        binary_isa("X86");
        binary_isa("X64")
    ),
    // CALL pushes program counter to stack,
    direct_call(Src,Dest),
    // POP loads program counter from the stack.
    next(Src,Dest),
    instruction_get_operation(Dest,"POP").

.decl halt(EA:address)

halt(EA):-
    arch.halt_operation(Operation),
    instruction_get_operation(EA,Operation).

/**
Auxiliary predicate that builds initial alignments from `alignment_required`:
the max alignment is picked for an EA later.
*/
.decl alignment_candidate(EA:address,AlignInBits:unsigned)

// Data in code needs to be aligned when referenced by instruction that
// requires aligned memory: e.g., some SIMD instructions
alignment_candidate(DataEA, AlignInBits):-
    arch.alignment_required(EA,AlignInBits),
    code(EA),
    (
        pc_relative_operand(EA,_,DataEA);
        composite_data_access(_,EA,DataEA,AlignInBits)
    ),
    data_segment(Begin,End),
    DataEA >= Begin,
    DataEA < End.

/**
Information about alignment in bits for a given address
*/
.decl alignment(EA:address,AlignInBits:unsigned)
.output alignment

alignment(DataEA, AlignInBits):-
    alignment_candidate(DataEA, AlignInBits),
    AlignInBits = max X: {alignment_candidate(DataEA, X)}.

//////////////////////////////////////////////////////////////////////////////////
// Operations to abstract features of instructions

.decl op_indirect_contains_reg(Op:operand_code,Reg:register)

// we ignore segment registers
op_indirect_contains_reg(Op,Reg):-
    op_indirect(Op,_,RegIn,_,_,_,_),
    reg_map(RegIn,Reg).

op_indirect_contains_reg(Op,Reg):-
    op_indirect(Op,_,_,RegIn,_,_,_),
    reg_map(RegIn,Reg).

.decl op_indirect_mapped(Op:operand_code,Reg1:reg_nullable,Reg2:reg_nullable,Reg3:reg_nullable,Mult:number,Offset:number,Size:unsigned)

op_indirect_mapped(Op,Reg1,Reg2,Reg3,Mult,Offset,Size):-
    op_indirect(Op,RegIn1,RegIn2,RegIn3,Mult,Offset,Size),
    reg_map_nullable(RegIn1,Reg1),
    reg_map_nullable(RegIn2,Reg2),
    reg_map_nullable(RegIn3,Reg3).

.decl op_regdirect_contains_reg(Op:operand_code,Reg:register)

op_regdirect_contains_reg(Op,Reg):-
    (
        op_regdirect(Op,RegIn)
        ;
        op_register_bitfield(Op,_,RegIn)
    ),
    reg_map(RegIn,Reg).

// The instruction at EA has operation Operation and two operands: a register Reg and an immediate Immediate
.decl op_immediate_and_reg(EA:address,Operation:symbol,Reg:register,Imm_index:operand_index,Immediate:number)

op_immediate_and_reg(EA,Operation,Reg,Imm_index,Immediate):-
    instruction_get_operation(EA,Operation),
    instruction_get_op(EA,Imm_index,Op),
    op_immediate(Op,Immediate,_),
    instruction_get_op(EA,_,Op2),
    op_regdirect_contains_reg(Op2,Reg).

// The instruction at EA is a comparison between a register Reg and an immediate Immediate
.decl cmp_immediate_to_reg(EA:address,Reg:register,Imm_index:operand_index,Immediate:number)

cmp_immediate_to_reg(EA,Reg,Imm_index,Immediate):-
    op_immediate_and_reg(EA,Operation,Reg,Imm_index,Immediate),
    arch.cmp_operation(Operation),
    (
        !arch.jump(EA);
        arch.jump(EA), arch.jump_operation_op_index(Operation,JumpTargetIndex), Imm_index != JumpTargetIndex
    ).

/////////////////////////////////////////////////////////////////////////////////

.decl symbol_set(ea:address,size:unsigned,type:symbol,scope:symbol,visibility:symbol,sectionIndex:unsigned,name:symbol)

symbol_set(EA,Size,Type,Scope,Visibility,SectIndex,Name):-
    symbol(EA,Size,Type,Scope,Visibility,SectIndex,_,_,Name).

.decl ambiguous_symbol(name:symbol)

ambiguous_symbol(Name):-
    symbol_set(_,_,_,_,_,_,Name),
    1 < count :{symbol_set(_,_,_,_,_,_,Name)}.

// Function symbols
.decl function_symbol(ea:address,name:symbol)

function_symbol(EA,Name):-
    symbol(EA,_,"FUNC",_,_,_,_,_,Name).

function_symbol(EA,Name):-
    symbol(EA,_,"GNU_IFUNC",_,_,_,_,_,Name).

.decl defined_symbol(ea:address,size:unsigned,type:symbol,scope:symbol,visibility:symbol,sectionIndex:unsigned,originTable:symbol,tableIndex:unsigned,name:symbol)

defined_symbol(EA,Size,Type,Scope,Visibility,SectIndex,OriginTable,TableIndex,Name):-
    symbol(EA,Size,Type,Scope,Visibility,SectIndex,OriginTable,TableIndex,Name),
    // In executables, the section index can be irrelevant
    // so we check whether the symbol has non-zero address too.
    (SectIndex != 0; EA != 0),
    // Avoid most special section indexes
    // See https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-94076.html#chapter6-tbl-16
    (
        SectIndex < 0xff00; // SHN_LORESERVE
        SectIndex = 0xfff1; // SHN_ABS
        SectIndex > 0xffff  // SHN_HIRESERVE
    ),
    // Avoid FILE symbols.
    Type != "FILE".

/**
The name of symbol table to use when looking up symbols from relocations

Although it'd be better to check what symbol table is referenced by the
relocation section's sh_link attribute, LIEF (as of 0.13.0) does not expose
this metadata in the LIEF::ELF::Relocation object. LIEF actually uses a similar
strategy to this, using dynsym if it exists, and otherwise symtab - rather than
using the sh_link metadata.

This strategy will fail for binaries built with --emit-relocs, since they can
have relocations referencing both symbol tables.
*/
.decl relocation_active_symbol_table(Name:symbol)

relocation_active_symbol_table(".dynsym"):-
    binary_format("ELF"),
    !binary_type("REL").

relocation_active_symbol_table(".symtab"):-
    binary_format("ELF"),
    binary_type("REL").

relocation_active_symbol_table(""):-
    binary_format("PE").

////////////////////////////////////////////////////////////////////////////////////////

.decl loaded_section(Beg:address,End:address,Name:symbol)
.decl data_section(name:symbol)
.decl exception_section(name:symbol)
.decl special_data_section(name:symbol)
.decl regular_data_section(name:symbol)
.decl code_section(name:symbol)
.decl tls_section(name:symbol)
.decl bss_section(name:symbol)
.output bss_section

loaded_section(Beg,Beg+Size,Name):-
    section(Name,Size,Beg,_,_),
    section_property(Name,"Loaded").

code_section(Section):-
    section(Section,_,_,_,_),
    section_property(Section,"Executable").

tls_section(Section):-
    data_section(Section),
    section_property(Section,"ThreadLocal").

regular_data_section(Name):-
    data_section(Name),
    !special_data_section(Name).

.decl non_zero_data_section(name:symbol)

.decl bss_section_limits(Begin:address,End:address)

bss_section_limits(0,0):-
    !bss_section(_).

bss_section_limits(Begin,End):-
    Begin = min X:{ bss_section(Name),loaded_section(X,_,Name)},
    End = max X:{ bss_section(Name),loaded_section(_,X,Name)}.

/*
data segments can be data sections or fragments of the code section that
contain data instead of code.
*/

.decl initialized_data_segment(Begin:address,End:address)
.output initialized_data_segment

initialized_data_segment(Begin,End):-
    non_zero_data_section(Section),
    loaded_section(Begin,End,Section).

initialized_data_segment(Begin,End):-
    data_in_code(Begin,End).

.decl data_segment(Begin:address,End:address)

data_segment(Begin,End):-
    data_section(Section),
    loaded_section(Begin,End,Section).

data_segment(Begin,End):-
    initialized_data_segment(Begin,End).

////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)

/**
The basic block 'Block' implements a PLT thunk
that refers to function 'Function'.
*/
.decl plt_block(block:address,function:symbol)
.output plt_block

.decl got_reference(Got_entry:address,Symbol:symbol)
.output got_reference


.decl main_function(ea:address)

.decl conditional_return(EA:address)

conditional_return(EA):-
    arch.return(EA),
    arch.conditional(EA,_).

.decl unconditional_return(EA:address)

unconditional_return(EA):-
    arch.return(EA),
    !arch.conditional(EA,_).


/**
Detects non-returning calls before even must/may fallthrough relations.

Calculated even before code inference.
*/
.decl no_return_call(EA:address)

.decl function_pointer_section(Name:symbol)

.decl no_return_function(Name:symbol)

no_return_call(EA):-
    direct_call(EA,Dest),
    plt_entry(Dest,Function),
    no_return_function(Pattern),
    match(Pattern,Function).

no_return_call(EA):-
    direct_call(EA,Dest),
    defined_symbol(Dest,_,_,_,_,_,_,_,Name),
    no_return_function(Pattern),
    match(Pattern,Name).

no_return_call(EA):-
    direct_call(EA,_),
    instruction_immediate_offset(EA,_,Offset,_),
    relocation(EA+Offset,_,_,_,SymbolIndex,_,_),
    symbol(_,_,_,_,_,_,_,SymbolIndex,Name),
    no_return_function(Pattern),
    match(Pattern,Name).

.decl is_padding(EA:address)

is_padding(EA):-
    arch.is_nop(EA).

/**
The set of printable ASCII characters.
*/
.decl printable_char(N:unsigned)

printable_char(0x9).
printable_char(0xA).
printable_char(0xC).
printable_char(0xD).
printable_char(N):-
    N = range(0x20,0x7E+1,1).

/**
Align address in 4-byte boundary
*/
.decl align_addr(AddrAligned:address,AddrOrig:address) inline

align_addr(AddrAligned,AddrOrig):-
    AddrAligned = AddrOrig - (AddrOrig band 3).

/*
The functions and data-objects that are intrinsic to the compiler's ABI -
artifacts of compilation that are not explicit features of the source and
will likely be reintroduced by the compiler toolchain.
*/
.decl abi_intrinsic(EA:address,Name:symbol)
.output abi_intrinsic
