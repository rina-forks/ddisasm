//===- code_inference.dl ------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module computes the valid instructions organized in blocks of
code.  It infers the facts `code_in_block`, `block`, and `code`.

Potential code inference failures are recorded in the `block_still_overlap`
and `interval_schedule_tie` relations.

The disassembly consists of several phases:

  - Traverse backward from invalid instructions through "must" edges
  - Traverse forward from "may" edges from all possible instructions to
    generate a superset of all possible code blocks in
    `code_in_block_candidate`. This traversal has a recursive component and a
    linear-sweep component.
  - Generate data block candidates using references from code block candidates
  - Split common block tails to ensure code blocks are non-overlapping in
    `code_in_block_candidate_refined`
  - Populate `known_block` based on binary metadata and propagate forward
    through "must" edges
  - Populate `impossible_block` with blocks which overlap known_blocks, and
    propagate backward through "must" edges
  - Identify remaining overlapping blocks in `unresolved_block` and assign
    points in `block_points` and `block_points_proportional` according to heuristics.
  - Resolve blocks with different boundaries using weighted interval
    scheduling, which weights blocks according to points and binary coverage
  - Resolve blocks with identical boundaries according to their points.
*/

// The postprocess refines the blocks by merging contiguous blocks
// that are always executed together
#include "code_inference_postprocess.dl"

// cfg generates a control flow graph
#include "cfg.dl"

/**
The instruction at address 'EA' belong to the block 'Block'.
The block address is the address of the first instruction in the block.
These are final addresses where the code is located.
They are organized in blocks of sequential code
and the block identifier is the address of the first instruction in the block.
*/
.decl code_in_block(EA:address,Block:address)

/**
There is a code block starting at 'Block'.
*/
.decl block(Block:address)
/**
The instruction at address 'EA' is code.
*/
.decl code(EA:address) inline

/**
The last instruction of 'Block' is at address 'EA'
*/
.decl block_last_instruction(Block:address,EA:address)

/**
The block defined by address 'Block' extends from 'BegAddr' to 'EndAddr'.
In most cases 'BegAddr' and 'Block' coincide, but there are exceptions such as
ARM 32 Thumb code blocks.
*/
.decl block_boundaries(block:address,BegAddr:address,EndAddr:address)

/**
Predicate to capture overlapping instructions. Certain overlapping instructions
are permitted and do not generate block conflicts. Those overlapping
instructions are captured by this predicate.
*/
.decl overlapping_instruction(EA:address, EA2: address)

/**
There is a segment of data in a code section that spans from 'Begin' to 'End'.
*/
.decl data_in_code(Begin:address,End:address)

/**
A block candidate can be a "code", "data", or "padding" block candidate.
*/
.type block_type <: symbol
/**
This predicate if there are still overlapping blocks after the
code inference. In that case the analysis has failed to resolve all conflicts.
*/
.decl block_still_overlap(Block1:address,Type1:block_type,Size1:unsigned,Block2:address,Type2:block_type,Size2:unsigned)
.output block_still_overlap


/////////////////////////////////////////////////////////////
// Basic facts to define fallthrough

/**
Instruction at address `From` might fallthrough to
instruction at address `To`.
*/
.decl may_fallthrough(From:address,To:address)

// Branch with a delay-slot can always fallthrough
may_fallthrough(From,To):-
    next(From,To),
    arch.delay_slot(From,To).

// Delay-slot can fallthrough if the corresponding branch is not unconditional
// or a return.
may_fallthrough(From,To):-
    next(From,To),
    arch.delay_slot(Prev,From),
    !unconditional_return(Prev),
    !unconditional_jump(Prev).

// Common case
may_fallthrough(From,To):-
    next(From,To),
    !arch.delay_slot(_,From),
    !unconditional_return(From),
    !unconditional_jump(From),
    !halt(From),
    !no_return_call(From).

/**
Instruction at address `From` must fallthrough to
instruction at address `To`.
*/
.decl must_fallthrough(From:address,To:address)

// Branch with a delay-slot must fallthrough
must_fallthrough(From,To):-
    next(From,To),
    arch.delay_slot(From,To).

must_fallthrough(From,To):-
    may_fallthrough(From,To),
    instruction_get_operation(From,Operation),
    !arch.call_operation(Operation),
    !arch.syscall_operation(Operation),
    !arch.interrupt_operation(Operation),
    !instruction_has_loop_prefix(From),
    !conditional_jump(From),
    !conditional_return(From),
    !arch.delay_slot(_,From).

/**
This predicate is a special case of `may_fallthrough`.
`must_fallthrough` is very conservative and does not include
things like conditional jumps. However, conditional jumps
can almost always fallthrough (unless there is obfuscation).
`likely_fallthrough` captures those instructions.
*/
.decl likely_fallthrough(From:address,To:address)


likely_fallthrough(From,To):-
    may_fallthrough(From,To),
    (
        instruction_has_loop_prefix(From);
        conditional_jump(From)
    ).

//////////////////////////////////////////////////////////////
// This is a small refinement for discarding immediates as targets
// in some obvious cases. This is specially useful for PIE code where
// the address space starts from 0 (and therefore we have many more collisions).

.decl may_have_symbolic_immediate(src:address,dest:address)

may_have_symbolic_immediate(Src,as(Dest,address)):-
    instruction_immediate_offset(Src,Index,Offset,_),
    instruction_get_op(Src,Index,Op),
    op_immediate(Op,Dest,_),
    (
        binary_type("DYN"),
        relocation(Src+Offset,_,_,_,_,_,_)
        ;
        binary_type("REL"),
        relocation(Src+Offset,_,_,_,_,_,_)
        ;
        binary_type("EXEC"),
        !binary_isa("ARM"),
        instruction_get_operation(Src,Operation),
        !arch.logic_operation(Operation),
        Offset = Offset // avoid warning
    ).

.decl unlikely_have_symbolic_immediate(EA:address)
unlikely_have_symbolic_immediate(0):- false.

.decl invalid(EA:address,Type:symbol)

// if the decoder failed to decode any instruction at EA, EA is invalid
invalid(EA,Type):-
    invalid_op_code(EA),
    Type = "invalid_op_code".

invalid(EA,Type):-
    !binary_format("RAW"),
    (
        // EA is a direct call or jump to something that cannot be code, it is invalid.
        direct_call(EA,Dest),       Type = "direct_call to invalid";
        direct_jump(EA,Dest),       Type = "direct_jump to invalid";
        // EA is followed by something that cannot be code.
        must_fallthrough(EA,Dest),  Type = "must_fallthrough to invalid"
    ),
    !instruction(Dest,_,_,_,_,_,_,_,_,_),
    Dest != 0.

/**
Largest instruction in the binary
*/
.decl max_instruction_size(Size:unsigned)

max_instruction_size(MaxSize):-
    MaxSize = max Size : {
        instruction(_,Size,_,_,_,_,_,_,_,_)
    }.

invalid(Inst,"overlaps object"):-
    defined_symbol(Start,ObjSize,"OBJECT",_,_,_,_,_,_),
    max_instruction_size(MaxInstSize),
    arch.instruction_at(EA,Inst),
    Start-MaxInstSize < EA,
    EA < Start+ObjSize,
    instruction(Inst,InstSize,_,_,_,_,_,_,_,_),
    Start < EA+InstSize.

// propagate the invalid instructions backwards until ret or jmp (encoded in must_fallthrough)
// propagate through direct jumps and calls
invalid(From,"propagate from invalid"):-
    invalid(To,_),
    (
        must_fallthrough(From,To);
        direct_jump(From,To);
        direct_call(From,To);
        pc_relative_jump(From,To);
        pc_relative_call(From,To)
    ).

invalid(EA,"known data region"):-
    data_region(Begin,Size),
    instruction(EA,_,_,_,_,_,_,_,_,_),
    Size > 0, EA >= Begin, EA < (Begin + Size).

// It is unlikely that EA is a valid instruction if the dest op is zero.
invalid(EA,"mips-zero_dest_op"):-
    binary_isa("MIPS"),
    instruction_get_dest_op(EA,_,Op),
    !instruction_get_operation(EA, "MOVE"),
    op_regdirect_contains_reg(Op,"ZERO").

// Prior to capstone 662bb3f, it did not support decoding ARM64 udf
// instructions. This retains that behavior, for now.
// Binutils <2.35 does not support assembling udf instructions on ARM64.
// TODO: ideally, we would add UDF to arch.halt_operation() and rely on code
// inference to avoid it. However, ARM64 does not yet create data blocks for
// jump tables, and relative jump table entries frequently decode as UDF.
invalid(EA,"arm64-udf"):-
    binary_isa("ARM64"),
    instruction_get_operation(EA,"UDF").

invalid(EA+1,"INT3"):-
    binary_format("PE"),
    (
         binary_isa("X86");
         binary_isa("X64")
    ),
    instruction_get_operation(EA,"INT3"),
    instruction_get_operation(EA+1,"INT3"),
    instruction_get_operation(EA+2,"INT3").

.decl possible_ea(EA:address) inline

possible_ea(EA):-
    instruction(EA,_,_,_,_,_,_,_,_,_),
    !invalid(EA,_).


/**
The address EA is already known to be code in the input GTIRB.
*/
.decl known_code(EA:address)
.input known_code

/**
Starting addresses for code exploration.
*/
.decl basic_target(ea:address)

basic_target(Val):-
    (
        known_code(Val)
        ;
        relative_address(_,_,_,_,Val,_)
        ;
        binary_type("DYN"),
        address_in_data(EA,Val),
        relocation(EA,_,_,_,_,_,_)
        ;
        binary_type("REL"),
        address_in_data(EA,Val),
        relocation(EA,_,_,_,_,_,_)
        ;
        binary_type("EXEC"),
        address_in_data(_,Val)
        ;
        entry_point(Val)
        ;
        dynamic_entry("INIT",Addr),
        Val = as(Addr,address)
        ;
        dynamic_entry("FINI",Addr),
        Val = as(Addr,address)
        ;
        code_section(Name),
        loaded_section(BegSect,EndSect,Name),
        byte_interval(BegByteInterval,_),
        BegSect <= BegByteInterval, BegByteInterval < EndSect,
        arch.instruction_at(BegByteInterval,Val)
        ;
        !binary_isa("ARM"),
        defined_symbol(Val,_,Type,_,_,_,_,_,_),
        Type != "OBJECT"
        ;
        // ELF exception information
        fde_addresses(Val,_),
        !misaligned_fde_start(Val,_)
        ;
        lsda_callsite_addresses(Val, _, _)
        ;
        lsda_callsite_addresses(_, _, Val)
        ;
        // PE32 exception information
        seh_handler_entry(_,Val)
    ).

.decl block_limit(EA:address)

block_limit(as(EA,address)):-
    (
        op_immediate(_,EA,_);
        pc_relative_operand(_,_,EA);
        basic_target(EA);
        instruction_has_loop_prefix(EA);
        fde_addresses(_,EA);
        lsda_callsite_addresses(_,EA, _)
    ).

// block limits before and after data accesses
block_limit(Inst):-
    (
        arch.simple_data_load(_,EA,_);
        composite_data_access(_,_,EA,_);
        arch.pc_relative_addr(_,_,EA)
    ),
    arch.instruction_at(EA,Inst).

block_limit(Inst):-
    (
        arch.simple_data_load(_,EA,Size);
        composite_data_access(_,_,EA,Size);
        repeated_byte(EA,_,Size), Size > 8
    ),
    arch.instruction_at(EA+Size,Inst).

/**
We want to split blocks that go from non-padding to padding
or from padding to non-padding.

However, this cannot be a regular block_limit because several
instructions could fallthrough into another one.
We need to consider the source address too.
*/
.decl transition_block_limit(EA:address,Next:address)

transition_block_limit(EA,Next):-
    is_padding(Next),
    next(EA,Next),
    !is_padding(EA).

transition_block_limit(EA,Next):-
    is_padding(EA),
    next(EA,Next),
    !is_padding(Next).

// The targets are computed incrementally now as we traverse the code
// likely_ea and possible_target_from are mutually recursive

.decl possible_target_from(dest:address,src:address)

possible_target_from(Dest,Src):-
    code_in_block_candidate(Src,_),
    (
        may_have_symbolic_immediate(Src,Dest),
        !arch.simple_data_load(Src,Dest,_)
        ;
        direct_jump(Src,Dest);
        direct_call(Src,Dest);
        jump_table_candidate(Src,_,_,Dest);
        pc_relative_jump(Src,Dest);
        pc_relative_call(Src,Dest);
        pc_relative_operand(Src,_,Dest),
        !arch.simple_data_load(Src,Dest,_)
    ).

.decl possible_target(Target:address)
.decl code_in_block_candidate(EA:address,EA_block:address)

possible_target(EA):-
    basic_target(EA).

possible_target(EA):-
    possible_target_from(EA,_).

/**
Aligned address shown in data
*/
.decl aligned_address_in_data(EA:address,Value:address)
aligned_address_in_data(EA,Value):-
    address_in_data(EA,Value),
    arch.pointer_size(Pt_size),
    EA % Pt_size = 0.

// start a new block given a possible target
code_in_block_candidate(EA,EA):-
    possible_target(EA),
    possible_ea(EA).

// Extend the block as long as we are sure to fallthrough and we have not
// reached a block limit
code_in_block_candidate(EA,Start):-
    code_in_block_candidate(EA2,Start),
    must_fallthrough(EA2,EA),
    !block_limit(EA),
    !transition_block_limit(EA2,EA).


// If reached a block limit or an instruction that does not necessarily
// fallthrough continue exploring but start a new block
// Always start a new block if we switch to padding instructions.
code_in_block_candidate(EA,EA):-
    code_in_block_candidate(EA2,_),
    may_fallthrough(EA2,EA),
    (
        !must_fallthrough(EA2,EA);
        block_limit(EA);
        transition_block_limit(EA2,EA)
    ),
    possible_ea(EA).


/**
Addresses where the propagation of padding blocks should be limited.

Similar to (and a superset of) block_limit for code blocks.
*/
.decl padding_block_limit(Limit:address)

padding_block_limit(Start):-
    block_limit(Start).

padding_block_limit(Inst):-
    data_block_candidate(Start,_),
    arch.instruction_at(Start,Inst).

padding_block_limit(Inst):-
    data_block_candidate(Start,Size),
    arch.instruction_at(Start+Size,Inst).

/**
Build padding candidates from nop instructions

This is analogous to code_in_block_candidate, but for blocks of type "padding".
*/
.decl nop_in_padding_candidate(EA:address,Start:address)

nop_in_padding_candidate(EA,EA):-
    is_padding(EA),
    !code_in_block_candidate_refined(EA,_),
    next(Prev,EA),
    (
        !is_padding(Prev);
        code_in_block_candidate_refined(Prev,_)
    ).

nop_in_padding_candidate(EA,EA):-
    padding_block_limit(EA),
    is_padding(EA),
    !code_in_block_candidate_refined(EA,EA).

nop_in_padding_candidate(Next,Start):-
    nop_in_padding_candidate(EA,Start),
    next(EA,Next),
    is_padding(Next),
    !padding_block_limit(Next).

/**
Padding block candidates can help fill in space when evaluating overlapping
models.
*/
.decl padding_block_candidate(EA:address,Size:unsigned)

padding_block_candidate(Start,Next-Start):-
    nop_in_padding_candidate(EA,Start),
    next(EA,Next),
    !nop_in_padding_candidate(Next,Start).


/**
Linear component of the forward traversal. after_end traverses
the code lineraly skipping nops. Traversals starts at points
where there is a no-fallthough, after jump tables and after literal pools.
`End` represents where the traversal started and `EA` represents the current
address.
*/
.decl after_end(EA:address,End:address)

// Start propagating after no-fallthrough blocks
after_end(Next,End):-
    code_in_block_candidate(End,_),
    next(End,Next),
    !may_fallthrough(End,Next).

// If we have a may_fallthrough that goes to invalid, we start an after_end
// propagation.
after_end(Next,End):-
    code_in_block_candidate(End,_),
    may_fallthrough(End,Next),
    !must_fallthrough(End,Next),
    invalid(Next,_).

// Search after int3 instructions in PEs
after_end(Next,End):-
    binary_format("PE"),
    instruction_get_operation(End,"INT3"),
    next(End,Next),
    !instruction_get_operation(Next,"INT3").

// Search after jump tables and literal pools
after_end(Next,EA):-
    data_block_candidate(EA,Size),
    Next = EA + Size,
    !relative_address(Next,_,_,_,_,_).

// Search thumb code after literal pools
after_end(NextThumb,EA):-
    binary_isa("ARM"),
    data_block_candidate(EA,Size),
    NextThumb = EA + Size + 1.

// Propagation through nops
after_end(Next,End):-
    after_end(EA,End),
    is_padding(EA),
    next(EA,Next).


possible_target(EA):-
    after_end(EA,_),
    (
        !is_padding(EA);
        block_limit(EA)
    ).

// In ARM, if we find invalid instructions, we try with the other decode mode.
possible_target(SwitchDecodeModeEA):-
    binary_isa("ARM"),
    after_end(EA,_),
    !is_padding(EA),
    invalid(EA,_),
    SwitchDecodeModeEA = EA bxor 1.

///////////////////////////////////////////////////////////////////////
// We are done with the recursive exploration
// Now we detect and resolve conflicts within the different blocks

//First remove common tails
.decl common_tail(EA:address)

common_tail(EA):-
    code_in_block_candidate(EA,Block),
    code_in_block_candidate(EA,Block2),
    Block != Block2,
    next(EA_prev,EA),
    code_in_block_candidate(EA_prev,Block),
    !code_in_block_candidate(EA_prev,Block2).

.decl code_in_block_candidate_refined(EA:address,Block:address)

code_in_block_candidate_refined(Block,Block):-
    code_in_block_candidate(Block,Block).

code_in_block_candidate_refined(Block,Block):-
    common_tail(Block).

code_in_block_candidate_refined(EA_next,Block):-
    code_in_block_candidate_refined(EA,Block),
    next(EA,EA_next),
    // they used to be in the same block
    code_in_block_candidate(EA_next,OldBlock),
    code_in_block_candidate(EA,OldBlock),
    !code_in_block_candidate(EA_next,EA_next),
    !common_tail(EA_next).

/**
A pair of instructions form an access to data with a predetermined size and location
*/
.decl composite_data_access(EA:address,EA_load:address,Data:address,Size:unsigned)

composite_data_access(EA,EA_load,Data,Size):-
    arch.pc_relative_addr(EA,Reg,RefAddr),
    straight_line_def_used(EA,Reg,EA_load,_),
    arch.reg_relative_load(EA_load,Reg,Offset,Size),
    Data = as(as(RefAddr,number) + Offset,address).

/**
A data block candidate in a code section.
The candidate is located at address 'Block' and has 'Size' bytes.
*/
.decl data_block_candidate(Block:address,Size:unsigned)

data_block_candidate(Block,Size):-
    relative_address(Block,Size,_,_,_,_).

data_block_candidate(Block,Size):-
    arch.simple_data_load(EA,Block,Size),
    code_in_block_candidate(EA,_).

data_block_candidate(Block,AccessSize):-
    composite_data_access(EA,EA_load,Block,AccessSize),
    code_in_block_candidate(EA,_),
    code_in_block_candidate(EA_load,_).

// Repeated bytes in code section
data_block_candidate(EA,Size):-
    repeated_byte(EA,_,Size), Size > 8,
    !is_padding(EA).

data_block_candidate(Block,Size),
known_block(Block,"data",Size,"object symbol"):-
    defined_symbol(Block,Size,"OBJECT",_,_,_,_,_,_),
    Size > 0.

data_block_candidate(BegAddr,Size),
known_block(BegAddr,"data",Size,"seh handler table"):-
    seh_handler_table(BegAddr,EndAddr),
    Size = EndAddr - BegAddr.

data_block_candidate(Block,4),
known_block(Block,"data",4,"relocation"):-
    binary_format("PE"),
    // a relocation that does not match any instruction operand
    relocation(Block,"HIGHLOW",_,_,_,_,_),
    !instruction_has_relocation(_,Block),
    address_in_data(Block,_).

/**
String in code section, either it is referenced
or it is long enough (>8 bytes).

EA:    adr r0, RefAddr
...
RefAddr: .string "..."
*/
block_heuristic(RefAddr,"data",Size,0,"possible string"),
data_block_candidate(RefAddr,Size):-
    code_section(Name),
    loaded_section(BegSect,EndSect,Name),
    BegSect <= RefAddr, RefAddr < EndSect,
    ascii_string(RefAddr,End),
    Size = End - RefAddr,
    (
        arch.pc_relative_addr(EA,_,RefAddr),
        code_in_block_candidate(EA,_),
        !composite_data_access(EA,_,_,_)
        ;
        Size > 8
    ).

// Pointer to a string
data_block_candidate(Addr,Pt_size):-
    code_section(Name),
    loaded_section(BegSect,EndSect,Name),
    BegSect <= Addr, Addr < EndSect,
    aligned_address_in_data(Addr,Dest),
    ascii_string(StrBeg,StrEnd),
    StrBeg <= Dest, Dest < StrEnd,
    arch.pointer_size(Pt_size).
/**
The block candidate defined by address 'Block' extends from 'BegAddr' to 'EndAddr'.
In most cases 'BegAddr' and 'Block' coincide, but there are exceptions such as
ARM 32 Thumb code blocks. These block candidates can be code blocks or data blocks.
*/
.decl block_candidate_boundaries(Block:address,Type:block_type,BegAddr:address,EndAddr:address)

block_candidate_boundaries(Block,"code",Block,Next):-
    !binary_isa("ARM"),
    code_in_block_candidate_refined(EA,Block),
    next(EA,Next),
    !code_in_block_candidate_refined(Next,Block).

block_candidate_boundaries(Block,"code", BegAddr,EndAddr):-
    binary_isa("ARM"),
    code_in_block_candidate_refined(EA,Block),
    next(EA,Next),
    !code_in_block_candidate_refined(Next,Block),
    BegAddr = Block - (Block band 1),
    EndAddr = Next - (Next band 1).

block_candidate_boundaries(Block,"data",Block,Block+Size):-
    data_block_candidate(Block,Size).

block_candidate_boundaries(Block,"padding",Start,Start+Size):-
    padding_block_candidate(Block,Size),
    arch.instruction_at(Start,Block).

// auxiliary predicate to detect that there are several candidates that fallthrough into a third candidate block
.decl multiple_fallthrough_to(Block:address)

multiple_fallthrough_to(Block):-
    may_fallthrough(EA,Block),
    code_in_block_candidate_refined(EA,BlockPred),
    may_fallthrough(EA2,Block),
    code_in_block_candidate_refined(EA2,BlockPred2),
    BlockPred != BlockPred2.

/**
Two blocks overlap.
*/
.decl block_overlap(Block1:address,Type1:block_type,Size1:unsigned,Block2:address,Type2:block_type,Size2:unsigned)

block_overlap(Block1,Type1,Size1,Block2,Type2,Size2):-
    block_candidate_boundaries(Block1,Type1,BegAddr1,EndAddr1),
    block_candidate_boundaries(Block2,Type2,BegAddr2,EndAddr2),
    Size1 = EndAddr1-BegAddr1,
    Size2 = EndAddr2-BegAddr2,
    (
        Block1 != Block2
        ;
        Type1 != Type2
        ;
        Size1 != Size2
    ),
    BegAddr1 <= BegAddr2,
    BegAddr2 < EndAddr1.

block_overlap(Block2,Type2,Size2,Block1,Type1,Size1):-
    block_overlap(Block1,Type1,Size1,Block2,Type2,Size2).

/**
The block BlockA,TypeA implies the existence of of BlockB,TypeB
*/
.decl block_candidate_dependency_edge(BlockA:address,TypeA:block_type,SizeA:unsigned,BlockB:address,TypeB:block_type,SizeB:unsigned)

block_candidate_dependency_edge(BlockA,"code",EndAddrA-BegAddrA,BlockB,"code",EndAddrB-BegAddrB):-
    code_in_block_candidate_refined(EA,BlockA),
    (
        must_fallthrough(EA,BlockB);
        direct_jump(EA,BlockB);
        direct_call(EA,BlockB)
    ),
    !candidate_block_is_padding(BlockA),
    block_candidate_boundaries(BlockA,"code",BegAddrA,EndAddrA),
    block_candidate_boundaries(BlockB,"code",BegAddrB,EndAddrB),
    BlockA != BlockB.

block_candidate_dependency_edge(BlockA,"code",EndAddrA-BegAddrA,BlockB,"data",SizeB):-
    arch.simple_data_load(EA,BlockB,SizeB),
    code_in_block_candidate_refined(EA,BlockA),
    data_block_candidate(BlockB,SizeB),
    block_candidate_boundaries(BlockA,"code",BegAddrA,EndAddrA).

// composite data access in a single block
block_candidate_dependency_edge(BlockA,"code",EndAddrA-BegAddrA,BlockB,"data",SizeB):-
    composite_data_access(EA,EA_load,BlockB,SizeB),
    code_in_block_candidate_refined(EA,BlockA),
    code_in_block_candidate_refined(EA_load,BlockA),
    data_block_candidate(BlockB,SizeB),
    block_candidate_boundaries(BlockA,"code",BegAddrA,EndAddrA).

// composite data access is split between blocks, but the first block implies the other.
// thus, if the first block is selected, so must the data block.
block_candidate_dependency_edge(BlockA,"code",EndAddrA-BegAddrA,BlockC,"data",SizeC):-
    composite_data_access(EA,EA_load,BlockC,SizeC),
    code_in_block_candidate_refined(EA,BlockA),
    code_in_block_candidate_refined(EA_load,BlockB),
    block_implies_block(BlockA,"code",_,BlockB,"code",_),
    data_block_candidate(BlockC,SizeC),
    block_candidate_boundaries(BlockA,"code",BegAddrA,EndAddrA).

/**
If BlockA exists, BlockB must also exist.
*/
.decl block_implies_block(BlockA:address,TypeA:block_type,SizeA:unsigned,BlockB:address,TypeB:block_type,SizeB:unsigned)

block_implies_block(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB):-
    block_candidate_dependency_edge(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB),
    (
        // No need for SizeA != SizeB; data blocks are the only blocks that
        // can have different sizes for the same block ID, but they cannot
        // currently imply other blocks.
        BlockA != BlockB;
        TypeA != TypeB
    ),
    !overlapping_instruction(BlockB, BlockA),
    !overlapping_instruction(BlockA, BlockB).

block_implies_block(BlockA,TypeA,SizeA,BlockC,TypeC,SizeC):-
    block_implies_block(BlockB,TypeB,SizeB,BlockC,TypeC,SizeC),
    block_candidate_dependency_edge(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB),
    (
        BlockA != BlockC;
        TypeA != TypeC
    ),
    !overlapping_instruction(BlockC, BlockA),
    !overlapping_instruction(BlockA, BlockC).

/**
Known blocks are blocks that must exist due to metadata.
*/
.decl known_block(Block:address,Type:block_type,Size:unsigned,Reason:symbol)

// On ARM, both entry point and function symbols do use the low bit to indicate
// ARM/Thumb, so these rules are valid there as well.
known_block(Block,"code",Size,"entry point"):-
    !binary_type("REL"),
    entry_point(Block),
    block_candidate_boundaries(Block,"code",Beg,End),
    Size = End - Beg.

known_block(Block,"code",Size,"known code"):-
    known_code(Block),
    block_candidate_boundaries(Block,"code",Beg,End),
    Size = End - Beg.

known_block(Block,"code",Size,cat("DT_",Entry)):-
    (
        Entry = "INIT";
        Entry = "FINI"
    ),
    dynamic_entry(Entry,Block),
    block_candidate_boundaries(Block,"code",Beg,End),
    Size = End - Beg.

known_block(Block,"code",Size,"function symbol"):-
    function_symbol(Block,_),
    block_candidate_boundaries(Block,"code",Beg,End),
    Size = End - Beg.

known_block(Block,"code",Size,"fde-entry"):-
    fde_addresses(Block,_),
    !misaligned_fde_start(Block,_),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start.

known_block(Block,"code",Size,"pointer array section"):-
    binary_format("ELF"),
    function_pointer_section(SectionName),
    section(SectionName,SectionSize,Start,_,_),
    aligned_address_in_data(Entry,Block),
    Start <= Entry,
    Entry < Start+SectionSize,
    block_candidate_boundaries(Block,"code",Beg,End),
    Size = End - Beg.

// Propagate forward from known blocks.
known_block(BlockB,TypeB,SizeB,"propagated"):-
    known_block(BlockA,TypeA,SizeA,_),
    block_candidate_dependency_edge(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB).

/**
Logically impossible blocks.
*/
.decl impossible_block(Block:address,Type:block_type,Size:unsigned,Reason:symbol)

// A known block discovered by propagation must discard overlapping blocks
impossible_block(BlockB,TypeB,SizeB,"overlaps known"):-
    known_block(BlockA,TypeA,SizeA,_),
    block_overlap(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB),
    !known_block(BlockB,TypeB,SizeB,_),
    !overlapping_instruction(BlockA,BlockB),
    // overlapping data blocks are allowed
    (
        TypeA != "data";
        TypeB != "data"
    ).

// Propagate impossible blocks backward
impossible_block(BlockA,TypeA,SizeA,"propagated impossible"):-
    impossible_block(BlockB,TypeB,SizeB,_),
    block_candidate_dependency_edge(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB),
    !known_block(BlockA,TypeA,SizeA,_).

impossible_block(BlockA,TypeA,SizeA,"implies self-overlapping block"):-
    block_implies_block(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB),
    block_overlap(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB),
    !known_block(BlockA,TypeA,SizeA,_).

impossible_block(BlockA,TypeA,SizeA,"implies overlapping blocks"):-
    block_implies_block(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB),
    block_implies_block(BlockA,TypeA,SizeA,BlockC,TypeC,SizeC),
    (
        BlockB != BlockC,
        // Implying overlapping data blocks is permissible; code might access
        // data both as a series of bytes and as a word, resulting in
        // different overlapping data blocks.
        TypeB != "data",
        TypeC != "data"
        ;
        TypeB != TypeC
    ),
    block_overlap(BlockB,TypeB,SizeB,BlockC,TypeC,SizeC),
    !known_block(BlockA,TypeA,SizeA,_).

/**
Blocks that are still overlapping after known_block and impossible_block are determined.
*/
.decl unresolved_block(Block:address,Type:block_type,Size:unsigned)

unresolved_block(Block,Type,Size):-
    block_candidate_boundaries(Block,Type,Beg,End),
    Size = End - Beg,
    !known_block(Block,Type,Size,_),
    !impossible_block(Block,Type,Size,_),
    // Has a possible overlap
    block_overlap(Block,Type,Size,Other,OtherType,OtherSize),
    !impossible_block(Other,OtherType,OtherSize,_),
    (
        Type != "data";
        OtherType != "data"
    ).

// If an unresolved data block overlaps with another data block, make both
// unresolved.
unresolved_block(Other,"data",OtherSize):-
    unresolved_block(Block,"data",Size),
    block_overlap(Block,"data",Size,Other,"data",OtherSize),
    !impossible_block(Other,"data",OtherSize,_).

// If some rule assigns negative points, make sure positive point rules are considered.
unresolved_block(Block,Type,Size):-
    negative_block_heuristic(Block,Type,Size,_,_),
    !known_block(Block,Type,Size,_),
    !impossible_block(Block,Type,Size,_).

/**
Blocks that still overlap after known_block and impossible_block are determined.
*/
.decl unresolved_block_overlap(Block1:address,Type1:block_type,Size1:unsigned,Block2:address,Type2:block_type,Size2:unsigned)

unresolved_block_overlap(Block1,Type1,Size1,Block2,Type2,Size2):-
    block_overlap(Block1,Type1,Size1,Block2,Type2,Size2),
    unresolved_block(Block1,Type1,Size1),
    unresolved_block(Block2,Type2,Size2),
    // overlapping data blocks are allowed
    (
        Type1 != "data";
        Type2 != "data"
    ).

//////////////////////////////////////////////////////////////////////
// Weighted interval scheduling
//
// This algorithm is typically applied in job scheduling, where the intervals
// represent jobs that must occur at a certain time with a certain duration,
// and the maximal total priority for all jobs must be selected.
//
// Here, we use it to select blocks, maximizing the total selected weight.
// It can be solved in linear time utilizing dynamic programming, and is easy
// to implement in datalog.
//
// Unfortunately, it is unable to express dependencies between blocks, and we
// must account for that in the weights.
//
// The following unresolved_interval* relations establish the intervals to be
// "scheduled", and the wis_* relations implement the algorithm itself.
//
// For details of the algoritm's implementation, see:
// https://www.cs.umd.edu/class/fall2017/cmsc451-0101/Lects/lect10-dp-intv-sched.pdf

/**
A numerical value that encodes the type of the interval for the WIS algorithm.
*/
.type interval_type <: unsigned

/**
This predicate allows us to translate back and forth from block types (padding, code, or data)
into numerical interval types that are easily sorted. For padding and code blocks, we can
have Default or Thumb blocks and we distinguish those with a different interval type.
The field `AddrAdjust` allows us to adjust the addresses of Thumb blocks.

This predicate also defines an implicit priority. If two blocks have the same weight
and the same boundaries, the one with higher interval_type will be chosen.
This derives from the way we deal with ties in the WIS algorithm. In case of a tie,
the algorithm selects the block, which means that the last block in the ordering will
be selected first.
*/
.decl type_ordering_map(Type:block_type,IntervalType:interval_type,AddrAdjust:address)

type_ordering_map("padding",0,0).
// padding thumb
type_ordering_map("padding",1,1).
type_ordering_map("code",2,0).
// code thumb
type_ordering_map("code",3,1).
type_ordering_map("data",4,0).

/**
Valid unresolved intervals
*/
.decl unresolved_interval(Start:address,End:address,TypeOrd:interval_type,Weight:number)

unresolved_interval(Start,End,IntervalType, Points):-
    unresolved_block(Block,Type,Size),
    block_total_points(Block,Type,Size,Points),
    type_ordering_map(Type,IntervalType,AddrAdjust),
    Start = Block - AddrAdjust,
    block_candidate_boundaries(Block,Type,Start,End),
    Size = End - Start.



/**
Auxiliary predicate to help sorting the intervals.
`next_type` captures the next type for a fixed start and end addresses.
*/
.decl next_type(Start:address,End:address,PrevType:interval_type,NextType:interval_type)

/**
Auxiliary predicate to help sorting the intervals.
`next_start` captures the next starting address for a fixed end address.
*/
.decl next_start(PrevStart:address,End:address,NextStart:address)

/**
Auxiliary predicate to help sorting the intervals.
`next_end` captures the next end address overall.
*/
.decl next_end(PrevEnd:address,NextEnd:address)

next_type(Start,End,PrevType,NextType):-
    unresolved_interval(Start,End,PrevType,_),
    NextType = min Type : {
        unresolved_interval(Start,End,Type,_),
        Type > PrevType
    }.

next_start(PrevStart,End,NextStart):-
    unresolved_interval(PrevStart,End,_,_),
    NextStart = min Start : {
        unresolved_interval(Start,End,_,_),
        Start > PrevStart
    }.

next_end(PrevEnd,NextEnd):-
    unresolved_interval(_,PrevEnd,_,_),
    NextEnd = min End : {
        unresolved_interval(_,End,_,_),
        End > PrevEnd
    }.


/**
Sort intervals lexicographically by <end address, start address, interval_type>
*/
.decl unresolved_interval_order(ID:unsigned,Start:address,End:address,Type:interval_type,Weight:number)

unresolved_interval_order(ID,FirstStart,FirstEnd,FirstType,Weight):-
    ID = 1,
    FirstEnd = min End : {
        unresolved_interval(_,End,_,_)
    },
    FirstStart = min Start : {
        unresolved_interval(Start,FirstEnd,_,_)
    },
    FirstType = min Type : {
        unresolved_interval(FirstStart,FirstEnd,Type,_)
    },
    unresolved_interval(FirstStart,FirstEnd,FirstType,Weight).

unresolved_interval_order(ID+1,Start,End,NextType,Weight):-
    unresolved_interval_order(ID,Start,End,Type,_),
    next_type(Start,End,Type,NextType),
    unresolved_interval(Start,End,NextType,Weight).

unresolved_interval_order(ID+1,NextStart,End,FirstType,Weight):-
    unresolved_interval_order(ID,Start,End,PrevType,_),
    !next_type(Start,End,PrevType,_),
    next_start(Start,End,NextStart),
    FirstType = min Type : {
        unresolved_interval(NextStart,End,Type,_)
    },
    unresolved_interval(NextStart,End,FirstType,Weight).

unresolved_interval_order(ID+1,FirstStart,NextEnd,FirstType,Weight):-
    unresolved_interval_order(ID,PrevStart,End,PrevType,_),
    !next_type(PrevStart,End,PrevType,_),
    !next_start(PrevStart,End,_),
    next_end(End,NextEnd),
    FirstStart = min Start : {
        unresolved_interval(Start,NextEnd,_,_)
    },
    FirstType = min Type : {
        unresolved_interval(FirstStart,NextEnd,Type,_)
    },
    unresolved_interval(FirstStart,NextEnd,FirstType,Weight).


/**
Weighted interval schedule: `Count` of intervals that end prior to the start of
interval `I`.

Only calculated for intervals that have prior intervals.
*/
.decl wis_has_prior(I:unsigned,Count:unsigned)

wis_has_prior(I,Prior):-
    unresolved_interval_order(Prior,_,PriorEnd,_,_),
    // check the we have the last interval ending at PriorEnd
    unresolved_interval_order(Prior+1,_,NextEnd,_,_),
    NextEnd > PriorEnd,
    // find intervals that start after PriorEnd but before NextEnd.
    // for those intervals `Prior` is the prior.
    unresolved_interval_order(I,Start,_,_,_),
    NextEnd > Start, Start >= PriorEnd.

/**
wis_prior extends wis_has_prior, including intervals that have no prior
intervals (i.e., with `Count` of 0).
*/
.decl wis_prior(I:unsigned,Count:unsigned)

wis_prior(I,0):-
    unresolved_interval_order(I,_,_,_,_),
    !wis_has_prior(I,_).

wis_prior(I,Prior):-
    wis_has_prior(I,Prior).

/**
If Val1 >= Val2, return Id1. Otherwise, return Id2.
*/
.functor functor_choose_max(Val1:number,Val2:number,Id1:unsigned,Id2:unsigned):unsigned

/**
Weighted interval schedule: memoized subproblems

Value is the optimized total weight for intervals [1:I].

`Value` is the total weight for selected intervals, and `Pred` (i.e., the
Predecessor) is the previous entry in `wis_memo`, later used to reconstruct
the optimal solution.
*/
.decl wis_memo(I:unsigned,Value:number,Pred:unsigned)

wis_memo(0,0,0).

wis_memo(I,Value,Pred):-
    wis_memo(IPrev,LeaveWeight,_),
    // specifying this expression in both forms allows it to be indexed in both rule plans.
    I = IPrev + 1,
    IPrev = I - 1,
    unresolved_interval_order(I,_,_,_,IWeight),
    wis_prior(I,P),
    wis_memo(P,TakeWeight0,_),
    TakeWeight = TakeWeight0 + IWeight,
    Value = max(LeaveWeight,TakeWeight),
    // functor_choose_max used for efficiency here instead of a disjunction
    // for performance.
    // In case of equality, it defaults to including P.
    Pred = @functor_choose_max(LeaveWeight,TakeWeight,IPrev,P).

// ensure @delta_wis_memo is evaluated first in both plans
.plan 1: (4, 3, 2, 1)

/**
Blocks A and B had equal weights during interval scheduling, and Block A was
selected.
*/
.decl interval_schedule_tie(BlockA:address,TypeA:block_type,SizeA:unsigned,BlockB:address,TypeB:block_type,SizeB:unsigned)
.output interval_schedule_tie

interval_schedule_tie(BlockA,TypeA,SizeA,BlockB,TypeB,SizeB):-
    wis_memo(IPrev,LeaveWeight,_),
    I = IPrev + 1,
    unresolved_interval_order(I,StartA,EndA,IntervalTypeA,IWeight),

    SizeA = as(EndA - StartA,unsigned),
    type_ordering_map(TypeA,IntervalTypeA,AddrAdjustA),
    BlockA = StartA + AddrAdjustA,

    // Don't warn if the selected block is later discarded.
    !discarded_block(BlockA,TypeA,SizeA,_,_),
    wis_prior(I,P),
    wis_memo(P,TakeWeight0,_),
    TakeWeight = TakeWeight0 + IWeight,
    LeaveWeight = TakeWeight,
    unresolved_interval_order(IPrev,StartB,EndB,IntervalTypeB,_),

    SizeB = as(EndB - StartB,unsigned),
    type_ordering_map(TypeB,IntervalTypeB,AddrAdjustB),
    BlockB = StartB + AddrAdjustB,

    // We only care about ties if I is selected in the final schedule.
    // Otherwise, it had no impact on the output.
    // It's a non-issue if IPrev is selected. Because the wis_memo rule favors
    // interval I in case of ties, then if IPrev was selected, some interval
    // after IPrev but conflicting with I was selected.
    wis_schedule(I).

/**
Weighted interval schedule: reconstruct schedule of selected intervals
*/
.decl wis_schedule(Interval:unsigned)

.decl wis_schedule_iter(Iter:unsigned)

// Start from the end, which holds the completed optimal solution.
wis_schedule_iter(I):-
    unresolved_interval_order(I,_,_,_,_),
    !unresolved_interval_order(I+1,_,_,_,_).

// Add to schedule if interval I was taken.
wis_schedule(I):-
    wis_schedule_iter(I),
    wis_memo(I,_,P),
    wis_prior(I,P).

// Follow predecessor pointers
wis_schedule_iter(Pred):-
    wis_schedule_iter(I),
    wis_memo(I,_,Pred).

//////////////////////////////////////////////////////////////////////
// We need to solve the block overlaps
// we do it with heuristics
///
.decl block_total_points(Block:address,Type:block_type,Size:unsigned,Points:number)

block_total_points(Block,Type,Size,Points + Proportional_points):-
    unresolved_block(Block,Type,Size),
    Points = sum X:{block_points(Block,Type,Size,_,X,_)},
    Proportional_points = sum X:{block_points_proportional(Block,Type,Size,Mult,_), X = as(Size,number)*Mult}.

/**
Block: block to be discarded
BlockPropagated (for debugging purpose):
     - previous block that the reason is propagated from (for "propagated")
     - block that this block overlapped with (for "first instruction overlap")
*/
.decl discarded_block(Block:address,Type:block_type,Size:unsigned,Reason:symbol,BlockPropagated:address)

discarded_block(Block,Type,Size,"interval discarded",0):-
    unresolved_interval_order(I,Start,End,IntervalType,_),
    Size = End - Start,
    !wis_schedule(I),
    type_ordering_map(Type,IntervalType,AddrAdjust),
    Block = Start + AddrAdjust,
    unresolved_block(Block,Type,Size).


// If both a code and data block are both known, and the data block is only
// known by propagation, discard the data block.
// Most likely the size of the data block is wrong. The code will be kept,
// and any data that doesn't overlap with code will remain data.
// One example, observed on ARM, where a known code block includes this
// instruction:
//    vld1.16        {d0, d1, d2, d3}, [ip:0x80]
// which populates four floating point registers with the consecutive eight-byte
// data blocks starting at the referenced address. However, the data block
// started just before the code block, and its last eight bytes
// overlapped with the beginning of the code block. Analysis of the code found
// that d3 was actually unused; the "real" size of the data block was only 24
// bytes and the first eight bytes of code is loaded as data into d3 as a
// harmless side effect.
discarded_block(Block2,Type2,Size2,"overlaps known code",Block1):-
    block_overlap(Block1,Type1,Size1,Block2,Type2,Size2),
    known_block(Block1,Type1,Size1,_),
    known_block(Block2,Type2,Size2,"propagated"),
    Type1 = "code", Type2 = "data".


discarded_block(Block,Type,Size,"impossible",0):-
    impossible_block(Block,Type,Size,_).

// propagate discarding blocks through direct jumps, calls, and must_fallthrough
discarded_block(Block1,Type1,Size1,"propagated",Block2):-
    discarded_block(Block2,"code",Size2,_,_),
    !overlapping_instruction(Block2,_),
    block_candidate_dependency_edge(Block1,Type1,Size1,Block2,"code",Size2),
    (
        unresolved_block(Block1,Type1,Size1)
        ;
        // it's non-overlapping, but depends on a discarded block.
        !unresolved_block_overlap(Block1,Type1,Size1,_,_,_)
    ).

//////////////////////////////////////////////////////////////////////
//special cases

// two blocks where the first instruction is overlapping and only different because of a prefix
// we discard the second block but register the instruction without prefix as code
overlapping_instruction(Block2,Block),
discarded_block(Block2,"code",Block2Size,"first instruction overlap",Block):-
    block_overlap(Block,"code",_,Block2,"code",Block2Size),
    // one has an extra prefix with respect to the other
    instruction(Block,Size,"LOCK",OpCode,Op1,Op2,Op3,Op4,_,_),
    Block2 = Block + 1,
    instruction(Block2,Size2,"",OpCode,Op1,Op2,Op3,Op4,_,_),
    Block2 - Block = Size - Size2.

// Auxiliary predicates to detect candidate blocks that are padding
.decl candidate_block_is_not_padding(Block:address)

candidate_block_is_not_padding(Block):-
    code_in_block_candidate_refined(EA,Block),
    !is_padding(EA).

.decl candidate_block_is_padding(Block:address)

candidate_block_is_padding(Block):-
    code_in_block_candidate_refined(_,Block),
    !candidate_block_is_not_padding(Block).


/**
`block_heuristic` defines properties of blocks that will receive points. This predicate
uniquely identifies a block and the 'HeuristicName' property associated to it.

Some heuristics can be assigned to a block multiple times, this is made possible by
the 'Instance' field. E.g. if we give points for specific instructions in the block
or for each block predecessor. For heuristics that can only be applied once per block, the
instance field is always 0.
*/
.decl block_heuristic(Block:address,Type:block_type,Size:unsigned,Instance:address,HeuristicName:symbol)

/**
Negative block heuristics are collected in their own relation.

This allows any block with negative_block_heuristic to be marked as
unresolved_block without causing cyclic negation.
*/
.decl negative_block_heuristic(Block:address,Type:block_type,Size:unsigned,Instance:address,HeuristicName:symbol)

/**
 A block defined by its address 'Block', 'Type', and 'Size' has been assigned a heuristic 'HeuristicName'
 with weight 'Weight'. The 'Instance' field can be used to assign a single heuristic to a block multiple times,
 see `block_heuristics`.
 The heuristic weights are determined by the `heuristic_weight` predicate.
*/
.decl block_points(Block:address,Type:block_type,Size:unsigned,Instance:address,Weight:number,HeuristicName:symbol)

/**
This predicate specifies heuristics whose weight is proportional to the block size.
A block defined by its address 'Block', 'Type', and 'Size' has been assigned a heuristic 'HeuristicName'
 with weight 'WeightMult'*'Size'.
*/
.decl block_points_proportional(Block:address,Type:block_type,Size:unsigned,WeightMult:number,HeuristicName:symbol)


block_points(Block,Type,Size,Instance,Weight,HeuristicName):-
    block_heuristic(Block,Type,Size,Instance,HeuristicName),
    heuristic_weight(HeuristicName,SIMPLE_WEIGHT,Weight).

block_points(Block,Type,Size,Instance,Weight,HeuristicName):-
    negative_block_heuristic(Block,Type,Size,Instance,HeuristicName),
    heuristic_weight(HeuristicName,SIMPLE_WEIGHT,Weight).

block_points_proportional(Block,Type,Size,Weight,HeuristicName):-
    block_heuristic(Block,Type,Size,_,HeuristicName),
    heuristic_weight(HeuristicName,PROPORTIONAL_WEIGHT,Weight).

block_heuristic(Block,Type,Size,0,"size"):-
    unresolved_block(Block,Type,Size).


//////////////////////////////////////////////////////////////////////
// data block candidate heuristics

block_heuristic(Block,"data",Size,0,"relative-jump-table"):-
    data_block_candidate(Block,Size),
    relative_address(Block,Size,_,_,_,_).


block_heuristic(Block,"data",Size,0,"relative-jump-table-start"):-
    data_block_candidate(Block,Size),
    relative_address_start(Block,_,_,_,_).

//////////////////////////////////////////////////////////////////////
// code block candidate points

block_heuristic(Block,"code",BlockSize,0,"overlaps with relocation"):-
    (
        binary_isa("X86");
        binary_isa("X64")
    ),
    code_in_block_candidate_refined(EA,Block),
    (
        // Block beginning intersects relocation bytes:
        relocation_size(Type,Size),
        relocation(Target,Type,_,_,_,_,_),
        EA >= Target, EA < Target + (Size/8)
        ;
        // Relocation target is in block but not aligned with operand offsets.
        instruction(EA,Size,_,_,_,_,_,_,_,_),
        relocation(Target,_,_,_,_,_,_),
        Target > EA, Target < EA + (Size/8),
        !instruction_immediate_offset(EA,_,Target-EA,_),
        !instruction_displacement_offset(EA,_,Target-EA,_)
    ),
    block_candidate_boundaries(Block,"code",Start,End),
    BlockSize = End - Start.

block_heuristic(Block,Type,Size,0,"basic point"):-
    unresolved_block(Block,Type,Size).

block_heuristic(Block,"code",Size,0,"code section start"):-
    unresolved_block(Block,"code",Size),
    code_section(Section),
    loaded_section(Block,_,Section).

block_heuristic(Block,"code",Size,0,"aligned address in data"):-
    !binary_isa("X86"),
    !binary_isa("ARM"),
    unresolved_block(Block,"code",Size),
    aligned_address_in_data(_,Block).

block_heuristic(Block,"code",Size,0,"address in data array"):-
    !binary_isa("ARM"),
    unresolved_block(Block,"code",Size),
    address_in_data(Address,Block),
    arch.pointer_size(Pt_size),
    (
      binary_format("PE");
      Address % Pt_size = 0
    ),
    (
        address_in_data(Address+Pt_size,_),
        address_in_data(Address+Pt_size*2,_)
        ;
        address_in_data(Address-Pt_size,_),
        address_in_data(Address-Pt_size*2,_)
        ;
        address_in_data(Address+Pt_size,_),
        address_in_data(Address-Pt_size,_)
    ).

block_heuristic(Block,"code",Size,BlockPred,"unresolved-direct-jump"):-
    unresolved_block(Block,"code",Size),
    direct_jump(EA,Block),
    code_in_block_candidate_refined(EA,BlockPred),
    BlockPred != Block,
    unresolved_block(BlockPred,"code",_).


block_heuristic(Block,"code",Size,BlockPred,"unresolved-direct-call"):-
    unresolved_block(Block,"code",Size),
    direct_call(EA,Block),
    code_in_block_candidate_refined(EA,BlockPred),
    BlockPred != Block,
    unresolved_block(BlockPred,"code",_).

block_heuristic(Block,"code",Size,0,"unresolved-may-fallthrough"):-
    unresolved_block(Block,"code",Size),
    may_fallthrough(EA,Block),
    code_in_block_candidate_refined(EA,BlockPred),
    !candidate_block_is_padding(BlockPred),
    unresolved_block(BlockPred,"code",_).

block_heuristic(Block,"code",Size,0,"incremental linking target"):-
    incremental_linking(First,Last),
    direct_jump(EA,Block),
    EA >= First, EA <= Last,
    unresolved_block(Block,"code",Size).

/**
Points for reachability

Give points to blocks that are reachable from a non-overlapping block.
We distinguish two kinds of reachability "strong" and "weak" which get
different amount of points. "weak" reachability is for may fallthroughs
that have higher uncertainty such as function calls.
*/
.decl resolved_reaches(Block:address,Size:unsigned, Type:symbol)

// Base cases: a non-overlapping block reaches a block
resolved_reaches(Block,Size, "strong"):-
    unresolved_block(Block,"code",Size),
    (
        must_fallthrough(EA,Block);
        likely_fallthrough(EA,Block);
        direct_jump(EA,Block);
        direct_call(EA,Block);
        jump_table_candidate(EA,_,_,Block)
    ),
    code_in_block_candidate_refined(EA,BlockPred),
    // No fallthrough from padding blocks
    !candidate_block_is_padding(BlockPred),
    !unresolved_block(BlockPred,"code",_),
    !impossible_block(BlockPred,"code",_,_).

resolved_reaches(Block,Size, "weak"):-
    unresolved_block(Block,"code",Size),
    may_fallthrough(EA,Block),
    !likely_fallthrough(EA,Block),
    code_in_block_candidate_refined(EA,BlockPred),
    // No fallthrough from padding blocks
    !candidate_block_is_padding(BlockPred),
    !unresolved_block(BlockPred,"code",_),
    !impossible_block(BlockPred,"code",_,_).

// Propagation
resolved_reaches(Block,Size,Type):-
    unresolved_block(Block,"code",Size),
    (
        must_fallthrough(EA,Block);
        likely_fallthrough(EA,Block);
        direct_jump(EA,Block);
        direct_call(EA,Block);
        jump_table_candidate(EA,_,_,Block)
    ),
    code_in_block_candidate_refined(EA,BlockPred),
    resolved_reaches(BlockPred,_,Type).

resolved_reaches(Block,Size,"weak"):-
    unresolved_block(Block,"code",Size),
    may_fallthrough(EA,Block),
    !likely_fallthrough(EA,Block),
    code_in_block_candidate_refined(EA,BlockPred),
    resolved_reaches(BlockPred,_,_).

// "strong" reachability subsumes "weak" reachability.
resolved_reaches(Block,Size,"weak") <= resolved_reaches(Block,Size,"strong"):- true.


block_heuristic(Block,"code",Size,0,cat("resolved-reaches ",Type)):-
    resolved_reaches(Block,Size,Type).

// its address appears somewhere
block_heuristic(Block,"code",Size,0,"appears"):-
    unresolved_block(Block,"code",Size),
    possible_target_from(Block,EA),
    !unlikely_have_symbolic_immediate(EA),
    !direct_jump(EA,Block),
    !direct_call(EA,Block),
    code_in_block_candidate_refined(EA,BlockPred),
    BlockPred != Block,
    !unresolved_block(BlockPred,"code",_),
    !impossible_block(BlockPred,"code",_,_).

block_heuristic(Block,"code",Size,0,Heuristic):-
    unresolved_block(Block,"code",Size),
    relative_address(EA,_,_,_,Block,_),
    count :{ relative_address(EA,_,_,_,_,_) } = 1,
    !relative_address(Block,_,_,_,_,_),
    (
        !address_in_data(EA,_),
        Heuristic = "relative jump table target"
        ;
        // If it is possible that EA has an absolute address instead of
        // a relative address, give less points.
        address_in_data(EA,_),
        Heuristic = "relative jump table target: absolute"
    ).

// give a point if it may fallthrough to another block
block_heuristic(Block,"code",Size,Block_succ,"fallthrough_to"):-
    unresolved_block(Block,"code",Size),
    code_in_block_candidate_refined(EA,Block),
    may_fallthrough(EA,Block_succ),
    code_in_block_candidate_refined(_,Block_succ),
    !unresolved_block(Block_succ,"code",_),
    !impossible_block(Block_succ,"code",_,_),
    !is_padding(Block_succ).

block_heuristic(Block,"code",Size,0,"has well-defined jump"):-
    unresolved_block(Block,"code",Size),
    code_in_block_candidate_refined(EA,Block),
    direct_jump(EA,BlockDest),
    !unresolved_block(BlockDest,"code",_).

block_heuristic(Block,"code",Size,0,"has well-defined call"):-
    unresolved_block(Block,"code",Size),
    code_in_block_candidate_refined(EA,Block),
    direct_call(EA,BlockDest),
    !unresolved_block(BlockDest,"code",_).

block_heuristic(Block,"code",Size,0,"has well-defined call to a function symbol"):-
    unresolved_block(Block,"code",Size),
    code_in_block_candidate_refined(EA,Block),
    direct_call(EA,BlockDest),
    function_symbol(BlockDest,_).

block_heuristic(Block,"code",Size,0,"plt call"):-
    unresolved_block(Block,"code",Size),
    code_in_block_candidate_refined(EA,Block),
    direct_call(EA,BlockDest),
    plt_entry(BlockDest,_).

block_heuristic(Block,"code",Size,0,"padding nop block"):-
    unresolved_block(Block,"code",Size),
    fde_addresses(_,Block),
    arch.is_nop(Block).

block_heuristic(Block,"data",Size,0,"repeated byte"):-
    unresolved_block(Block,"data",Size),
    repeated_byte(Block,_,Count), Count >= 8,
    !is_padding(Block).

/**
Give penalty on the dangling block where one or two instructions are enclosed
in a bigger instruction.
*/
block_heuristic(Block2,"code",BlockSize2,0,"dangling block with enclosed instr"):-
    unresolved_block_overlap(Block,"code",_,Block2,"code",BlockSize2),
    Block < Block2,
    instruction(Block,Size,_,_,_,_,_,_,_,_),   // Instr
    instruction(Block2,Size2,_,_,_,_,_,_,_,_), // Instr2
    (
        Block+Size = Block2+Size2; // Instr2 is enclosed in Instr at the end.
        instruction(Block2+Size2,Size3,_,_,_,_,_,_,_,_), // Instr3
        code_in_block_candidate_refined(Block2+Size2,Block2),
        Block+Size = Block2+Size2+Size3 // Instr2 and Instr3 are enclosed in Instr at the end.
    ),
    block_candidate_boundaries(Block2,"code",Beg2,_),
    !block_candidate_boundaries(_,"code",_,Beg2).

block_heuristic(Block,"code",Size,0,"exc-region"):-
    unresolved_block(Block,"code",Size),
    lsda_callsite_addresses(Block, _, _).

block_heuristic(Block,"code",Size,0,"landing-pad"):-
    unresolved_block(Block,"code",Size),
    lsda_callsite_addresses( _, _, Block).

negative_block_heuristic(Block,"code",Size,0,"conditional jump/return: fallthrough to invalid"):-
    code_in_block_candidate_refined(EA,Block),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start,
    (
        conditional_jump(EA);
        conditional_return(EA)
    ),
    next(EA,Invalid),
    invalid(Invalid,_).


negative_block_heuristic(Block,"code",Size,0,"jump to string"):-
    ascii_string(Beg,End),
    direct_jump(EA,Dest),
    Dest >= Beg,
    Dest < End,
    (
        symbol(Beg,_,_,_,_,_,_,_,_)
        ;
        aligned_address_in_data(_,Beg)
    ),
    code_in_block_candidate_refined(EA,Block),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start.

block_heuristic(Block,"code",Size,0,"seh handler"):-
    unresolved_block(Block,"code",Size),
    seh_handler_entry(_,Block).

block_heuristic(Block,"data",AccessSize,0,Heuristic):-
    !binary_isa("ARM"), // ARM's litpool_ref system gives points
    arch.simple_data_load(EA,Block,AccessSize),
    unresolved_block(Block,"data",AccessSize),
    code_in_block_candidate_refined(EA,Block0),
    (
        !unresolved_block(Block0,"code",_),
        !impossible_block(Block0,"code",_,_),
        Heuristic = "data access: resolved"
        ;
        unresolved_block(Block0,"code",_),
        Heuristic = "data access"
    ).

block_heuristic(Block,"data",AccessSize,0,Heuristic):-
    !binary_isa("ARM"), // ARM's litpool_ref system gives points
    composite_data_access(EA,EA_load,Block,AccessSize),
    unresolved_block(Block,"data",AccessSize),
    code_in_block_candidate_refined(EA,CodeBlock1),
    code_in_block_candidate_refined(EA_load,CodeBlock2),
    (
        !unresolved_block(CodeBlock1,"code",_),
        !impossible_block(CodeBlock1,"code",_,_),
        !unresolved_block(CodeBlock2,"code",_),
        !impossible_block(CodeBlock2,"code",_,_),
        Heuristic = "composite data access: 2 resolved"
        ;
        unresolved_block(CodeBlock1,"code",_),
        !unresolved_block(CodeBlock2,"code",_),
        !impossible_block(CodeBlock2,"code",_,_),
        Heuristic = "composite data access: 1 resolved"
        ;
        !unresolved_block(CodeBlock1,"code",_),
        !impossible_block(CodeBlock1,"code",_,_),
        unresolved_block(CodeBlock2,"code",_),
        Heuristic = "composite data access: 1 resolved"
        ;
        unresolved_block(CodeBlock1,"code",_),
        unresolved_block(CodeBlock2,"code",_),
        Heuristic = "composite data access"
    ).

block_heuristic(Block,"code",Size,0,"debug block"):-
    (
        binary_isa("X86");
        binary_isa("X64")
    ),
    unresolved_block(Block,"code",Size),
    block_candidate_boundaries(Block,"code",_,End),
    next(EA,End),
    code_in_block_candidate_refined(EA,Block),
    instruction_get_operation(EA,"INT3").

////////////////////////////////////////////////////////////////////////////


code_in_block(EA,Block):-
    code_in_block_candidate_refined(EA,Block),
    !discarded_block(Block,"code",_,_,_).

code_in_block(EA,Block):-
    overlapping_instruction(EA,Block),
    code_in_block(Block,Block).

block_last_instruction(Block,EA):-
    code_in_block(EA,Block),
    next(EA,Next),
    !code_in_block(Next,Block).

block_boundaries(Block,BegAddr,EndAddr),
block(Block):-
    code_in_block(_,Block),
    block_candidate_boundaries(Block,"code",BegAddr,EndAddr).

code(EA):-
    code_in_block(EA,_).

block_still_overlap(Block1,Type1,Size1,Block2,Type2,Size2):-
    block_overlap(Block1,Type1,Size1,Block2,Type2,Size2),
    !discarded_block(Block1,Type1,Size1,_,_),
    !discarded_block(Block2,Type2,Size2,_,_),
    // We only care about code-code or code-data conflicts
    // but not about data-data conflicts.
    (Type1 = "code"; Type2 = "code"),
    // Enforce ordering to prevent duplicate overlaps
    (
        Block1 < Block2
        ;
        Block1 = Block2,
        Size1 < Size2
        ;
        Block1 = Block2,
        Size1 = Size2,
        Type1 < Type2
    ).

/**
Auxiliary predicate to compute `data_in_code`. It propagates through
the holes between code blocks and between the last code block of
a byte interval and the end of the interval
*/
.decl data_in_code_propagate(Current:address,Initial:address,EndByteInterval:address)

data_in_code_propagate(BlockEndAddr,BlockEndAddr,EndByteInterval):-
    block_boundaries(_,_,BlockEndAddr),
    !block_boundaries(_,BlockEndAddr,_),
    byte_interval(BegByteInterval,EndByteInterval),
    BegByteInterval < BlockEndAddr, BlockEndAddr < EndByteInterval.

data_in_code_propagate(EA+1,Begin,EndByteInterval):-
    data_in_code_propagate(EA,Begin,EndByteInterval),
    !block_boundaries(_,EA+1,_),
    EA+1 < EndByteInterval.

/**
Auxiliary predicate to compute `data_in_code`.
`BlockBeg` contains the address of the first code block in the
byte interval defined by the addresses [Begin,End).
If a code byte interval has no code, no predicate will be generated.
*/
.decl first_block_in_byte_interval(Begin:address,End:address,BlockBeg:address)

first_block_in_byte_interval(Begin,End,BlockBeg):-
    code_section(Name),
    loaded_section(BegSect,EndSect,Name),
    byte_interval(Begin,End),
    BegSect <= Begin, End <= EndSect,
    BlockBeg = min EA:{ block_boundaries(_,EA,_), EA >= Begin, EA < End}.

// Data in between code blocks or between a code block and
// the end of a byte interval.
data_in_code(Begin,End+1):-
    data_in_code_propagate(End,Begin,_),
    !data_in_code_propagate(End+1,Begin,_).

// Data before the first code-block in a byte interval with code.
// If the byte interval has no code, the `data_in_code` predicate
// corresponds to the whole byte interval.
data_in_code(Begin,EndData):-
    code_section(Name),
    loaded_section(BegSect,EndSect,Name),
    byte_interval(Begin,End),
    BegSect <= Begin, End <= EndSect,
    (
        first_block_in_byte_interval(Begin,End,EndData)
    ;
        !first_block_in_byte_interval(Begin,End,_),
        EndData = End
    ),
    EndData > Begin.

.decl next_block_in_byte_interval(Block:address,NextBlock:address)
// This assumes there are no remaining overlapping blocks.

// This rule optimizes for the common case of contiguous blocks
next_block_in_byte_interval(Block,NextBlock):-
    block_boundaries(Block,_,NextBlockBeg),
    block_boundaries(NextBlock,NextBlockBeg,_).

next_block_in_byte_interval(Block,NextBlock):-
    block_boundaries(Block,_,BlockEndAddr),
    data_in_code(BlockEndAddr,NextBlockBeg),
    block_boundaries(NextBlock,NextBlockBeg,_).
